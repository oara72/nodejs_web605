# README

# Steps to Creating a JSON API #

*Note: File is best viewed in a editor with markdown preview turned on*

* Create a directory for the project ``` mkdir contact_book ```

* Navigate to that directory ``` cd contact_book ```

* Run the command ``` npm init ``` accepting all the defaults is fine

* Install the dependencies for the app ``` npm i async body-parser express morgan sequelize sequelize-cli sqlite3 -S ```
    * async: a library that will help the flow of our endpoints. It's usefulness will be more apparent on larger endpoints
    * body-parser: a library to parse the body of incoming requests. It exposes the body to us via ``` req.body ```
    * express: a minimal NodeJS framework
    * morgan: library that will log incoming requests to our app
    * sequelize: An ORM that works with various relational databases, in our case SQLite3
    * sequelize-cli: CLI for sequelize
    * sqlite3: Module that is required by Sequelize in order to connect to SQLite3 databases

* Install the development dependencies for the app ``` npm i nodemon -D ```
    * nodemon: monitors our codebase for changes, and restarts our app when one has been detected

* Open the project in your editor of choice

* Open the file "package.json" and add the following to scripts ``` "start": "nodemon app.js --ignore node_modules" ```

* Now create our main app file ``` touch app.js ```

* In app.js we will add the following:

```
// Run in strict mode
'use strict';

// Bring in the neccessary libraries
const http = require('http');
const express = require('express');
const morgan = require('morgan');
const bodyParser = require('body-parser');

// Create an instance of express
const app = express();
// Create a NodeJS server with our app instance
const server = http.createServer(app);

// Prints out requests
app.use(morgan('dev'));
// Parses incoming requests
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({
    extended: false
}));

// Setup a handler for any routes that aren't caught
app.use((req, res) => {
    res.status(404);
    res.json({
        statusCode: 404,
        message: 'Route not found'
    });
});

// Set our server to listen on port 3001
server.listen(3001, () => {
    var address = server.address();

    console.log(`Server listening on port ${ address.port }. Go to http://localhost:${ address.port }/`);
});

// Setup an error handler for our server
server.on('error', (err) => {
    console.log(err);
});
```

* We should now be able to run our app with the command ``` npm start ``` and it should be accessible at [http://localhost:3001](http://localhost:3001) and return the message ``` {"statusCode":404,"message":"Route not found"} ```

* Now we'll create our first route, we'll do so by creating the following directory structure in the root of our project "/routes/api/v1/"

* In the directory "v1" create a file called contacts.js

* Open contacts.js and add the following:

```
'use strict';

const express = require('express');
// Create an instance of express router
const router = express.Router();

// We'll define all endpoints under router, followed by the request type, the endpoint path, then the request and response object
router.get('/', (req, res) => {
    res.json('Hello');
});

// We must always export the router object in order to make it accessible when requiring it in our app.js file
module.exports = router;
```

* With that added return to the app.js file and add the following before we declare our 404 handler

```
// Require Routes
const v1Contacts = require('./routes/api/v1/contacts');

// Define Routes
app.use('/api/v1/contacts', v1Contacts);
```

* Now in the browser navigate to [http://localhost:3001/api/v1/contacts/](http://localhost:3001/api/v1/contacts/) and we should get a response of "Hello"

* Now with our first endpoint created and working we'll integrate SQLite and models into our app. We'll do this by running the following commands:
    * First run ``` ./node_modules/.bin/sequelize init:config ``` which will creat a config directory and config file which sequelize reads to determine what database we are using and any login information if needed
    * Second run ``` ./node_modules/.bin/sequelize init:models ``` which creates a models directory and a index.js file which loads all of our models into a single large object

* We'll now create our database, we'll do this with the following commands:
    * First we'll create a directory in the root of our project called data
    * Next we'll navigate into the directory we just created and create a .db file with ``` touch data.db ```

* With our database in place we'll empty autogenerated config file located in config/config.json and replace its contents with:
```
{
    "development": {
        "dialect": "sqlite",
        "storage": "./data/data.db"
    }
}
```

* The above JSON will tell sequelize that we are using SQLite3 and where it can find our database file

* Now we'll sync our sequelize models before we launch our application. We'll do this in app.js by:
    * First requiring in the models directory with ``` const models = require('./models'); ``` typically I'll put it with the other require statements
    * Second we'll wrap our server.listen command in the sequelize sync promise. It should look like this when completed:
    ```
    // Sync our sequelize models before starting our server, setting force to false prevents sequelize from emptying our database everytime our app restarts
    models.sequelize.sync({ force: false }).then(() => {
        server.listen(3001, () => {
            var address = server.address();

            console.log(`Server listening on port ${ address.port }. Go to http://localhost:${ address.port }/`);
        });

        server.on('error', (err) => {
            console.log(err);
        });
    });
    ```

* With those changes in place, our app should still seem to be functioning the same

* We'll now create our first model
    * First create a file called "contact.js" in the /models directory and add the following to it:
    ```
    'use strict';

    module.exports = (sequelize, DataTypes) => {
        var Contact = sequelize.define('contact', {
                // Creates a name property as a string, and enforces that it is a required field
                name: {
                    type: DataTypes.STRING,
                    validate: {
                        notEmpty: true
                    }
                },
                // Creates a email property as a string
                email: DataTypes.STRING,
                // Creates a phone number property as a string
                phone_number: DataTypes.STRING
        }, {
            // Gives us two additional properties created_at and updated_at in our model
            timestamps: true,
            // Ensures that multi-word models are separated with an _
            underscored: true
        });

        // Return the model so it can be loaded in
        return Contact;
    };
    ```

* With that in place we can now query our model in our previously created endpoint, we'll update our endpoint in routes/api/v1/contacts.js to the following:

```
'use strict';

const express = require('express');
const router = express.Router();
// Since we are now using sequelize to querying our database we must now include models
const models = require('../../../models');

router.get('/', (req, res) => {
    // I almost always create a responseData object to store the data I'll be returning from the endpoint
    let responseData = {};

    // All sequelize queries follow a similar pattern, first the model to query, then the query type
    models.contact.findAll({
        order: [
            ['id', 'ASC']
        ]
    // A successful query is handled in the "then" portion of the promise
    }).then((data) => {
        // We'll some values to the responseData object
        responseData.status = 200;
        responseData.message = 'Contacts retrieved successfully!';
        responseData.contacts = data;

        // Return with a appropriate status code
        res.status(responseData.status);
        // And return with the JSON
        res.json(responseData);
    // Errors from querying are handled in the "catch" portion of the promise
    }).catch((err) => {
        console.log(new Date());
        console.log(err);

        responseData.status = 500,
        responseData.message = 'Error getting Contacts.';

        res.status(responseData.status);
        res.json(responseData);
    });
});

module.exports = router;
```

* Now when we navigate to [http://localhost:3001/api/v1/contacts/](http://localhost:3001/api/v1/contacts/) we'll should see the following:

```
{"status":200,"message":"Contacts retrieved successfully!","contacts":[]}
```

* Since we have no contacts created or anyway to created them via our application we'll create an endpoint to create a contact immediately after our endpoint to get all contacts with the following code:

```
router.post('/', (req, res) => {
    let responseData = {};

    models.contact.create(req.body.contact).then((data) => {
        responseData.status = 201,
        responseData.message = 'Contact created successfully!';
        responseData.contact = data;

        res.status(responseData.status);
        res.json(responseData);
    }).catch((err) => {
        console.log(new Date());
        console.log(err);

        responseData.status = 500,
        responseData.message = 'Error creating Contact.';

        res.status(responseData.status);
        res.json(responseData);
    });
});
```

* With that in place we can send a request to that endpoint to create a contact, we'll do that in Postman (a small Postman guide is available on Blackboard in Content->Week1->Postman Info), we'll do the following in Postman
    * Set our request type to Postman
    * Set our URL to http://localhost:3001/api/v1/contacts/
    * In the body tab we'll select raw and our content-type as JSON and add the following JSON to our request body

    ```
    {
        "contact": {
            "name": "Shawn",
            "email": "test@email.com",
            "phone_number": "555 555 5555"
        }
    }
    ```

    * When we hit send it should return with the following:

    ```
    {
        "status": 201,
        "message": "Contact created successfully!",
        "contact": {
            "id": 1,
            "name": "Shawn",
            "email": "test@email.com",
            "phone_number": "555 555 5555",
            "updated_at": "2017-01-12T03:29:25.786Z",
            "created_at": "2017-01-12T03:29:25.786Z"
        }
    }
    ```

    * If we were to hit our get all contacts endpoint we should see our newly created contact in the array of contacts returned

* Now we'll create an endpoint to return a single contact by its unique ID
    * In the file contact.js add the following code between our two existing endpoints

    ```
    // We can define paramaters in our request with ":param", these become accessible via req.params
    router.get('/:contactId/', (req, res) => {
        let responseData = {};

        models.contact.findById(req.params.contactId).then((data) => {
            responseData.status = 200;
            responseData.message = 'Contact retrieved successfully!';
            responseData.contact = data;

            res.status(responseData.status);
            res.json(responseData);
        }).catch((err) => {
            console.log(new Date());
            console.log(err);

            responseData.status = 500,
            responseData.message = 'Error getting Contact.';

            res.status(responseData.status);
            res.json(responseData);
        });
    });
    ```

    * Now if we were to make a call to that endpoint in Postman we would get something like:

    ```
    {
        "status": 200,
        "message": "Contact retrieved successfully!",
        "contact": {
            "id": 1,
            "name": "Shawn",
            "email": "test@email.com",
            "phone_number": "555 555 5555",
            "created_at": "2017-01-12T03:37:58.516Z",
            "updated_at": "2017-01-12T03:37:58.516Z"
        }
    }
    ```

* We'll now make an endpoint to update a contact
    * In contacts.js at the top with the other request statements add

    ```
        const async = require('async');
    ```

    * We'll also add the following after our create endpoint

    ```
    router.put('/:contactId/', (req, res) => {
        let responseData = {};
        let contact;

        // Since we are doing multiple queries, we'll control the flow using the async library
        async.series([
            // Get the contact
            (callback) => {
                models.contact.findById(req.params.contactId).then((data) => {
                    // Ensure that the contact exists
                    if (data) {
                        // Set the returned data to the contact variable so it can be accessed by the next method in the series
                        contact = data;
                        return callback();
                    // If the contact doesn't exist return with a 404
                    } else {
                        responseData.status = 404,
                        responseData.message = 'Contact not found.';
                        return callback(new Error(responseData.message));
                    }
                }).catch((err) => {
                    responseData.status = 500,
                    responseData.message = 'Error getting Contact.';

                    return callback(err);
                });
            },

            // Update and save the contact
            (callback) => {
                contact.name = req.body.contact.name;
                contact.email = req.body.contact.email;
                contact.phone_number = req.body.contact.phone_number;

                contact.save().then((data) => {
                    responseData.contact = data;

                    return callback();
                }).catch((err) => {
                    responseData.status = 500,
                    responseData.message = 'Error updating Contact.';

                    return callback(err);
                });
            }
        // The final callback is where you check for errors handle the final response,
        ], (err) => {
            if (err) {
                console.log(new Date());
                console.log(err);

                res.status(responseData.status);
                res.json(responseData);
            } else {
                responseData.status = 200;
                responseData.message = 'Contact updated successfully!';

                res.status(responseData.status);
                res.json(responseData);
            }
        });
    });
    ```

    * If we make a request to that endpoint with the ID of an existing contact via Postman we should see the following returned:
    ```
    {
        "contact": {
            "id": 1,
            "name": "Shawn",
            "email": "test@updated.com",
            "phone_number": "555 555 5555",
            "created_at": "2017-01-12T03:56:20.067Z",
            "updated_at": "2017-01-12T03:56:30.081Z"
        },
        "status": 200,
        "message": "Contact updated successfully!"
    }
    ```

* Finally we'll make an endpoint to delete a contact
    * After our update endpoint add the following code:

    ```
    router.delete('/:contactId/', (req, res) => {
        let responseData = {};

        models.contact.destroy({
            where: {
                id: req.params.contactId
            }
        }).then(() => {
            responseData.status = 200,
            responseData.message = 'Contact deleted successfully!';

            res.status(responseData.status);
            res.json(responseData);
        }).catch((err) => {
            console.log(new Date());
            console.log(err);

            responseData.status = 500,
            responseData.message = 'Error deleting Contact.';

            res.status(responseData.status);
            res.json(responseData);
        });
    });
    ```

    * If we make a request to that endpoint via Postman we should see the following returned:

    ```
    {
        "status": 200,
        "message": "Contact deleted successfully!"
    }
    ```

With all that in place we should have a JSON API with the following endpoints:

* GET /api/v1/contacts/
* GET /api/v1/contacts/:contactId/
* POST /api/v1/contacts/
* PUT /api/v1/contacts/:contactId/
* DELETE /api/v1/contacts/:contactId/

Completed code is available at: [https://github.com/ShawnCC/web615_contactbook_backend/tree/week1](https://github.com/ShawnCC/web615_contactbook_backend/tree/week1)

